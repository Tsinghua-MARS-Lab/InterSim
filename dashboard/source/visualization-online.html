<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>InterSim - The Best Behaviour Simulator for Safe L4+ Autonomous Driving</title>

  <!-- GOOGLE FONTS -->
  <link href="https://fonts.googleapis.com/css?family=Karla:400,700|Roboto" rel="stylesheet">
  <link href="plugins/material/css/materialdesignicons.min.css" rel="stylesheet" />
  <link href="plugins/simplebar/simplebar.css" rel="stylesheet" />

  <!-- PLUGINS CSS STYLE -->
  <link href="plugins/nprogress/nprogress.css" rel="stylesheet" />
  <link href="plugins/DataTables/DataTables-1.10.18/css/jquery.dataTables.min.css" rel="stylesheet" />
  <link href="plugins/jvectormap/jquery-jvectormap-2.0.3.css" rel="stylesheet" />
  <link href="plugins/daterangepicker/daterangepicker.css" rel="stylesheet" />
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  <link href="plugins/toaster/toastr.min.css" rel="stylesheet" />
  <!-- MONO CSS -->
  <link id="main-css-href" rel="stylesheet" href="css/style.css" />
  <!-- FAVICON -->
  <link href="images/favicon.png" rel="shortcut icon" />

  <!--
    HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries
  -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="plugins/nprogress/nprogress.js"></script>
</head>


  <body class="navbar-fixed sidebar-fixed" id="body">
    <script>
      NProgress.configure({ showSpinner: false });
      NProgress.start();
    </script>

    <!-- ====================================
    ——— WRAPPER
    ===================================== -->
    <div class="wrapper">
        <!-- ====================================
          ——— LEFT SIDEBAR WITH OUT FOOTER
        ===================================== -->
        <aside class="left-sidebar sidebar-dark" id="left-sidebar">
          <div id="sidebar" class="sidebar">
            <!-- Aplication Brand -->
            <div class="app-brand">
              <a href="/index.html">
                <img class="mr-2" src="images/logo.png" alt="InterSim">
                <!-- <span class="brand-name">InterSim</span> -->
              </a>
            </div>
            <!-- begin sidebar scrollbar -->
            <div class="sidebar-left" data-simplebar style="height: 100%;">
              <!-- sidebar menu -->
              <ul class="nav sidebar-inner" id="sidebar-menu">
                  <li>
                    <a class="sidenav-item-link" href="index.html">
                      <i class="mdi mdi-home-variant-outline"></i>
                      <span class="nav-text">Simulations</span>
                    </a>
                  </li>

                  <li>
                    <a class="sidenav-item-link" href="analytics.html">
                      <i class="mdi mdi-console"></i>
                      <span class="nav-text">Console & Notebook</span>
                    </a>
                  </li>
                
                  <li>
                    <a class="sidenav-item-link" href="list.html">
                      <i class="mdi mdi-chart-line"></i>
                      <span class="nav-text">Results & Summary</span>
                    </a>
                  </li>

                  <li>
                    <a class="sidenav-item-link" href="visualization-detail.html">
                      <i class="mdi mdi-map"></i>
                      <span class="nav-text">Visualizations</span>
                    </a>
                  </li>

                  <li class="active">
                    <a class="sidenav-item-link" href="visualization-online.html">
                      <i class="mdi mdi-hand"></i>
                      <span class="nav-text">Online Simulation</span>
                    </a>
                  </li>
                
                  <li>
                    <a class="sidenav-item-link" href="user-profile.html">
                      <i class="mdi mdi-account"></i>
                      <span class="nav-text">User Profile</span>
                    </a>
                  </li>                
              </ul>
            </div>
          </div>
        </aside>

      

      <!-- ====================================
      ——— PAGE WRAPPER
      ===================================== -->
      <div class="page-wrapper">
        
          <!-- Header -->
          <header class="main-header" id="header">
            <nav class="navbar navbar-expand-lg navbar-light" id="navbar">
              <!-- Sidebar toggle button -->
              <button id="sidebar-toggler" class="sidebar-toggle">
                <span class="sr-only">Toggle navigation</span>
              </button>

              <span class="page-title">Online Simulation</span>

              <div class="navbar-right ">

                <a class="dropdown-link-item mr-5" href="http://www.bing.com" target="_blank">
                  <span class="nav-text">Qiao Sun &#64 Shanghai QiZhi</span>
                </a>

                <!-- <span herf="#www.bing.com" class="d-none d-lg-inline-block mr-5">Qiao Sun &#64 Shanghai QiZhi</span> -->
              </div>
            </nav>

          </header>

        <!-- ====================================
        ——— CONTENT WRAPPER
        ===================================== -->
        <div class="content-wrapper">
          <div class="content">     
            </div>
        </div>
          
        </div>
        
          <!-- Footer -->
          <footer class="footer mt-auto">
            <div class="copyright bg-white">
              <p>
                &copy; <span id="copy-year"></span> Copyright InterSim by <a class="text-primary" href="https://sqz.ac.cn/" target="_blank" >Shanghai QiZhi Institute</a>.
              </p>
            </div>
            <script>
                var d = new Date();
                var year = d.getFullYear();
                document.getElementById("copy-year").innerHTML = year;
            </script>
          </footer>

      </div>
    </div>
    
                    <script src="plugins/jquery/jquery.min.js"></script>
                    <script src="plugins/bootstrap/js/bootstrap.bundle.min.js"></script>
                    <script src="plugins/simplebar/simplebar.min.js"></script>
                    <script src="https://unpkg.com/hotkeys-js/dist/hotkeys.min.js"></script>
                    <script src="plugins/apexcharts/apexcharts.js"></script>
                    <script src="plugins/DataTables/DataTables-1.10.18/js/jquery.dataTables.min.js"></script>
                    <script src="plugins/jvectormap/jquery-jvectormap-2.0.3.min.js"></script>
                    <script src="plugins/jvectormap/jquery-jvectormap-world-mill.js"></script>
                    <script src="plugins/jvectormap/jquery-jvectormap-us-aea.js"></script>
                    <script src="plugins/daterangepicker/moment.min.js"></script>
                    <script src="plugins/daterangepicker/daterangepicker.js"></script>
                    <script>
                      jQuery(document).ready(function() {
                        jQuery('input[name="dateRange"]').daterangepicker({
                        autoUpdateInput: false,
                        singleDatePicker: true,
                        locale: {
                          cancelLabel: 'Clear'
                        }
                      });
                        jQuery('input[name="dateRange"]').on('apply.daterangepicker', function (ev, picker) {
                          jQuery(this).val(picker.startDate.format('MM/DD/YYYY'));
                        });
                        jQuery('input[name="dateRange"]').on('cancel.daterangepicker', function (ev, picker) {
                          jQuery(this).val('');
                        });
                      });
                    </script>
                    
                    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

                    <script src="plugins/toaster/toastr.min.js"></script>

                    
                    
                    <script src="js/mono.js"></script>
                    <script src="js/chart.js"></script>
                    <script src="js/map.js"></script>
                    <script src="js/custom.js"></script>

                    <!-- <script type="module" src="js/draw.js"></script> -->
                    <script src="js/two.js"></script>
                    <script src="js/zui.js"></script>

                    <!--  -->

                    <script>
                      // var agentData = require('data/agent_instances.json');
                      // console.log(agentData);
                      const queryString = window.location.search;
                      const urlParams = new URLSearchParams(queryString);
                      const product = urlParams.get('folder');
                      console.log(product);
                      
                      
                      function GetURLParameter(sParam)
                      {
                          var sPageURL = window.location.search.substring(1);
                          var sURLVariables = sPageURL.split('&');
                          for (var i = 0; i < sURLVariables.length; i++)
                          {
                              var sParameterName = sURLVariables[i].split('=');
                              if (sParameterName[0] == sParam)
                              {
                                  return sParameterName[1];
                              }
                          }
                      }
                      // pass in index or name to load
                      var task = GetURLParameter('task');
                      var dataset = GetURLParameter('dataset');
                      var simulation_name = GetURLParameter('sim_name');
                      var file_name = GetURLParameter('file_name');
                      var scenario_id = GetURLParameter('scenario_id');
                      var loadDemo = false;

                      if (typeof task == 'undefined' || typeof dataset == 'undefined' || typeof simulation_name == 'undefined'){
                        loadDemo = true;
                      }
                      else if (typeof file_name == 'undefined' || typeof scenario_id == 'undefined'){
                        loadDemo = true;
                      }
                      
                      var params = {
                      fullscreen: true,
                      autostart: true
                      };
                      
                      // var elem = document.getElementById('twoCanvas');
                      var elem = document.body;
                      // elem.style.height = (document.documentElement.clientHeight - 370).toString() + 'px';
                      // var elem = document.body;
                      var two = new Two(params).appendTo(elem);
                      two.renderer.domElement.style.background = 'rgb(0, 191, 168)';
                      // two.renderer.domElement.style.background = 'black';
                      // two.width = elem.clientWidth - 70;
                      // two.height = elem.clientHeight - 70;

                      var stage = new Two.Group();
                      var shape = new Two.Rectangle(0, 0, 1, 1);
                      var offsets = undefined;

                      // LANE = 0
                      // INTERSECTION = 1
                      // STOP_LINE = 2
                      // TURN_STOP = 3
                      // CROSSWALK = 4
                      // DRIVABLE_AREA = 5
                      // YIELD = 6
                      // TRAFFIC_LIGHT = 7
                      // STOP_SIGN = 8
                      // EXTENDED_PUDO = 9
                      // SPEED_BUMP = 10
                      // LANE_CONNECTOR = 11
                      // BASELINE_PATHS = 12
                      // WALKWAYS = 13
                      // CARPARK_AREA = 14
                      // PUDO = 15
                      // ROADBLOCK = 16
                      // ROADBLOCK_CONNECTOR = 17

                      const polyTypes = [16, 1];
                      const lineTypes = [0];
                      const rectTypes = [99];
                      const scale = 5;
                      const lineWidth = 1;
                      const xReverse = -1;
                      var agentPoly = {};
                      const btnOffset = 70;
                      var isPlaying = false;
                      var currentFrame = 0;
                      var totalFrame = undefined;
                      var loadedData = undefined;
                      var playBtn = two.load('./images/icons/play.svg');
                      var pauseBtn = two.load('./images/icons/pause.svg');
                      var timeText = undefined;
                      var agentGroup = new Two.Group();
                      var mapGroup = new Two.Group();
                      var goalGroup = new Two.Group();
                      var percCirclesGroup = new Two.Group();
                      var offsetFromLastFrame = [0, 0, 0];
                      var maxFrames = 80;
                      var lanes_to_mark = undefined;
                      var goal_pts = undefined;                    

                      function drawPoly(dic, selected){
                        const roadType = dic['type'];
                        if (selected.includes(roadType)){
                          var pointsArray = new Array();
                          const points = dic['xyz'];
                          for (let xyzArray of points){
                            if (offsets === undefined){
                              offsets = [-xyzArray[0], -xyzArray[1]];
                            }
                            pointsArray.push(new Two.Anchor((xyzArray[0]+offsets[0])*scale*xReverse, (xyzArray[1]+offsets[1])*scale));
                          }
                          var poly = two.makePath(pointsArray);
                          // draw polygons
                          // var poly = new two.makePath);
                          poly.linewidth = lineWidth / 2;
                          poly.opacity = 0.5;
                          if (polyTypes.includes(roadType)){
                            poly.fill = 'gray';
                            poly.opacity = 1;
                          }
                          else if (roadType == 4){
                            poly.fill = 'white';
                          }
                          else if (roadType == 2){
                            poly.fill = 'red';
                          }
                          else if (roadType == 13){
                            poly.fill = 'brown';
                          }
                          else if (roadType == 14){
                            poly.fill = 'blue';
                          }
                          else{
                            poly.fill = 'black';
                          }
                          mapGroup.add(poly);
                        }
                      }

                      function drawMap(roads){
                        for (var key in roads) {
                          drawPoly(roads[key], polyTypes);  // 17=1
                        }
                        // draw lanes
                        for (var key in roads) {
                          const dic = roads[key];
                          const roadType = dic['type'];
                          if (lineTypes.includes(roadType)){
                            var ptCounter = 0;
                            prev_x = undefined;
                            prev_y = undefined;
                            const points = dic['xyz'];

                            if (offsets === undefined){
                                offsets = [-points[0][0], -points[0][1]];
                              }
                            x0 = (points[0][0] + offsets[0]) * scale * xReverse;
                            y0 = (points[0][1] + offsets[1]) * scale;
                            if (true){  // (Math.abs(x0) < 3000 && Math.abs(y0) < 3000){
                              for (let xyzArray of points){
                                if (ptCounter == 10){
                                  ptCounter = 0;
                                }
                                else{
                                  ptCounter ++;
                                  continue;
                                }
                                if (prev_x === undefined){
                                  prev_x = (xyzArray[0] + offsets[0]) * scale * xReverse;
                                  prev_y = (xyzArray[1] + offsets[1]) * scale;
                                }
                                else{
                                  x = (xyzArray[0] + offsets[0]) * scale * xReverse;
                                  y = (xyzArray[1] + offsets[1]) * scale;
                                  if (lanes_to_mark !== undefined && lanes_to_mark.includes(key)){
                                    var line = two.makeArrow(prev_x, prev_y, x, y);
                                    prev_x = x;
                                    prev_y = y;
                                    line.stroke = 'black';
                                    line.linewidth = lineWidth*3;
                                  }
                                  else{
                                    var line = two.makeLine(prev_x, prev_y, x, y);
                                    prev_x = x;
                                    prev_y = y;
                                    line.stroke = 'white';
                                    line.linewidth = lineWidth;
                                }
                                  mapGroup.add(line);
                                  prev_x = undefined;
                                  prev_y = undefined;
                                }
                              }
                            }
                          }
                        }
                        // draw others
                        for (var key in roads) {
                          drawPoly(roads[key], [2, 4, 13, 14, 7, 8]);  // no 3, 5, 6
                        }

                        // draw parking lots
                        for (var key in roads) {  
                          const dic = roads[key];
                          const roadType = dic['type'];
                          if (rectTypes.includes(roadType)){
                            const points = dic['xyz'];
                            rectShape = dic['shape'];
                            x = (points[0] + offsets[0]) * scale * xReverse;
                            y = (points[1] + offsets[1]) * scale;
                            var rect = two.makeRectangle(x, y, rectShape[0]*scale, rectShape[1]*scale);
                            rect.rotation = Math.PI/2 - dic['dir'];
                            rect.fill = 'white';
                            rect.opacity = 0.3;
                            mapGroup.add(rect);
                          }                          
                        }

                        circle = two.makeCircle(two.width / 4, two.height / 4, 300*scale);
                        // circle.fill = 'gray';
                        circle.opacity = 0.2;
                        circle.stroke = 'red';
                        percCirclesGroup.add(circle);
                        circle = two.makeCircle(two.width / 4, two.height / 4, 150*scale);
                        // circle.fill = 'gray';
                        circle.stroke = 'green';
                        circle.opacity = 0.2;
                        percCirclesGroup.add(circle);
                        stage.add(percCirclesGroup);

                        stage.add(mapGroup);

                        for (var i = 0; i < 1; i++) {
                          var x = 0; //Math.random() * two.width * 2 - two.width;
                          var y = 0; //Math.random() * two.height * 2 - two.height;
                          var size = 10;
                          shape = new Two.Rectangle(x, y, size, size);
                          shape.rotation = Math.random() * Math.PI * 2;
                          shape.noStroke().fill = '#ccc';
                          // shape.opacity = 0.2;
                          stage.add(shape);
                        }

                        shape.fill = 'red';
                        shape.position.set(two.width / 4, two.height / 4);
                        two.add(stage);
                      }

                      function drawScenario(dataDic, scenarioId){
                        var agents = dataDic[scenarioId]['agent'];
                        for (var key in agents){
                          [x, y, z, yaw] = agents[key]['pose'][0];
                          if (totalFrame === undefined){
                            totalFrame = agents[key]['pose'].length;
                          }
                          // yaw = 0;
                          if (x == -1){
                            continue;
                          }
                          [w, h] = agents[key]['shape'][0];

                          var pointsArray = new Array();
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse-w*scale/2, (y+offsets[1])*scale-h*scale/2));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale-h*scale/2*1.3));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse+w*scale/2, (y+offsets[1])*scale-h*scale/2));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse+w*scale/2, (y+offsets[1])*scale+h*scale/2));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse-w*scale/2, (y+offsets[1])*scale+h*scale/2));
                          var poly = two.makePath(pointsArray);

                          // poly = new Two.Rectangle((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale, w*scale, h*scale);
                          if (key == 'ego'){
                            poly.fill = 'white';
                          }
                          else{
                            poly.fill = 'green';
                          }
                          // poly.rotation = -Math.PI/2+yaw;
                          // Math.PI/2 - dic['dir'];
                          // poly.rotation = yaw;
                          poly.rotation = -yaw - Math.PI/2;
                          agentPoly[key] = poly;
                          agentGroup.add(poly);
                        }
                        stage.add(agentGroup);
                      }

                      function drawGoals(dataDic, scenarioId){
                        // var goals = dataDic[scenarioId]['ltp_goals'];
                        // if (goals !== undefined){
                        //   goalGroup = new Two.Group();
                        //   for (var goal of goals){
                        //     const pt = goal[0];
                        //     [x, y] = pt;
                        //     // poly = two.makeArrow((x+offsets[0])*scale*xReverse, (y-5+offsets[1])*scale, 
                        //     // (x+offsets[0])*scale*xReverse, (y+offsets[1])*scale, 30);
                        //     // poly.center();
                        //     // poly.position.x = (x+offsets[0])*scale*xReverse;
                        //     // poly.position.y = (y+offsets[1])*scale;
                        //     // poly.stroke = 'red';
                        //     var line = two.makeLine((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale,
                        //     (x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale);
                        //     line.stroke = 'black';
                        //     goalGroup.add(line);
                        //     var circle = two.makeCircle((x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale, 2*scale);
                        //     circle.fill = 'red';
                        //     goalGroup.add(circle);
                        //   }
                        // }
                        // stage.add(goalGroup);
                        if (goal_pts !== undefined){
                          goalGroup = new Two.Group();
                          [x, y] = goal_pts;
                          var line = two.makeLine((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale, (x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale);
                          line.stroke = 'black';
                          goalGroup.add(line);
                          var circle = two.makeCircle((x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale, 2*scale);
                          circle.fill = 'red';
                          goalGroup.add(circle);                          
                          stage.add(goalGroup);
                        }
                      }

                      function setOffset(){
                        if (loadedData !== undefined && currentFrame !== undefined){
                          var ego = loadedData['agent']['ego'];
                          [x, y, z, yaw] = ego['pose'][currentFrame];
                          if (offsets !== undefined){
                            var dx = -x - two.width / 4 / scale - offsets[0];
                            var dy = -y + two.height / 4 / scale - offsets[1];
                            // var dyaw = -yaw - offsets[2];
                            // offsetFromLastFrame = [dx, dy, dyaw];
                            offsetFromLastFrame = [dx, dy, 0];
                          }
                          // offsets = [-x - two.width / 4 / scale, -y + two.height / 4 / scale, -yaw];
                          // offsets = [-x - two.width / 4 / scale, -y + two.height / 4 / scale, yaw*xReverse];
                          offsets = [-x - two.width / 4 / scale, -y + two.height / 4 / scale, 0];
                        }
                        if (lanes_to_mark === undefined){
                          lanes_to_mark = [];
                          for (const each_route of loadedData['agent']['ego']['current_route']){
                            for (const lane_id of each_route){
                              if (!lanes_to_mark.includes(lane_id)){
                                lanes_to_mark.push(lane_id);
                              } 
                            }
                          }
                          
                        }
                        if (goal_pts === undefined){
                          goal_pts = loadedData['goals']['ego'][0][0];
                        }
                      }

                      function addBtn(){
                          
                          var btnGroup = new Two.Group();

                          var panel = two.makeRoundedRectangle(two.width/2 + 70, two.height - 105, 190, 120, 35);
                          panel.fill = 'white';
                          btnGroup.add(panel);

                          playBtn.position.set(two.width/2 + 50 - btnOffset/2, two.height-140);
                          playBtn.scale = 0.07;
                          // playBtn.opacity = 1;
                          btnGroup.add(playBtn);

                          pauseBtn.position.set(two.width/2 + 50 - btnOffset/2, two.height-140);
                          pauseBtn.scale = 0.75;
                          pauseBtn.opacity = 0;
                          btnGroup.add(pauseBtn);

                          var resetBtn = two.load('./images/icons/reset.svg');
                          resetBtn.position.set(two.width/2 + 50 + btnOffset/2, two.height-145);
                          resetBtn.scale = 0.08;
                          btnGroup.add(resetBtn);

                          timeText = two.makeText('0.0', two.width/2 + 72, two.height-72);
                          btnGroup.add(timeText);
                          timeText.size = 20;
                          timeText.alignment = 'center';
                          timeText.weight = 300;

                          two.add(btnGroup);
                        }
                      
                      if (loadDemo){
                        file_name = 'demo.db';
                        scenario_id = 'demo_scenario';
                        console.log('Load with demo');

                        // loading (cannot save to local, because over the quota of local storage) 
                        fetch("./scenarios/demo/boston_map.json")
                        .then(response => response.json())
                        .then(data => {
                          const roads = data['map']['road'];
                          // const roads = Object.keys(data['map']['road']);
                          // localStorage['road'] = JSON.stringify(roads);
                          // console.log(JSON.parse(localStorage['road']));
                          
                          // fetch("./scenarios/demo/demo.json")
                          fetch("./scenarios/demo/2021.08.18.18.32.06_veh-28_00049_00111.json")
                          .then(response => response.json())
                          .then(data => {
                            var counter = 0;
                            for (var key of Object.keys(data)){
                              counter ++;
                              console.log(key + "->" + data[key]);
                              if (counter == 1){break;}
                            }
                            loadedData = data[key];
                            setOffset();
                            
                            drawMap(roads);
                            drawScenario(data, key);
                            drawGoals(data, key);

                            addBtn();
                            
                            // Bind a function to scale and rotate the group to the animation loop.
                            two.bind('update', update);
                            // Finally, start the animation loop
                            two.play();

                            addZUI();
                          })

                        })

                        
                          
                        


                        

                      }

                      // var info = {'file_names': ['1', '2', '3'], 'scenario_ids': [123, 234, 345]};
                      // localStorage['list'] = JSON.stringify(info);
                      // localStorage['list'] = [[0, 1], [2, 3], [4, 'sjdiofjs']];

                      function sendJSON(data){
                          
                        // Creating a XHR object
                        let xhr = new XMLHttpRequest();
                        let url = "http://localhost:8000";
                  
                        // open a connection
                        xhr.open("POST", url, true);
            
                        // Set the request header i.e. which type of content you are sending
                        xhr.setRequestHeader("Content-Type", "application/json");
            
                        // Create a state change callback
                        // xhr.onreadystatechange = function () {
                        //     if (xhr.readyState === 4 && xhr.status === 200) {
            
                        //         // Print received data from server
                        //         result.innerHTML = this.responseText;
            
                        //     }
                        // };
            
                        // Converting JSON data to string
                        // var data = JSON.stringify({ "name": name.value, "email": email.value });
            
                        // Sending data with the request
                        xhr.send(data);
                      }

                      var FRAMERATE = 6;  //10fps
                      
                      function update(frameCount){
                        if (isPlaying && playBtn.opacity == 1){
                          console.log('start post');
                          // sendJSON(loadedData);
                          console.log('end of post');
                        }
                        
                        if (isPlaying){
                          playBtn.opacity = 0;
                          pauseBtn.opacity = 1;
                        }
                        else{
                          playBtn.opacity = 1;
                          pauseBtn.opacity = 0;
                        }

                        if (isPlaying && totalFrame !== undefined && loadedData !== undefined 
                        && frameCount % FRAMERATE == 0){
                          if (currentFrame < totalFrame && currentFrame < maxFrames){
                            setOffset();
                            agents = loadedData['agent'];
                            for (var key in agentPoly){
                              poly = agentPoly[key];
                              [x, y, z, yaw] = agents[key]['pose'][currentFrame];
                              // [w, h] = agents[key]['shape'][currentFrame];
                              [w, h] = agents[key]['shape'][0];
                              poly.position.x = (x+offsets[0])*scale*xReverse;
                              poly.position.y = (y+offsets[1])*scale;
                              poly.rotation = - yaw - Math.PI/2;
                              // poly.rotation = yaw;
                              // poly.shape.width = w;
                              // poly.shape.height = h;
                            }
                            mapGroup.position.x += offsetFromLastFrame[0]*scale*xReverse;
                            mapGroup.position.y += offsetFromLastFrame[1]*scale;

                            goalGroup.position.x += offsetFromLastFrame[0]*scale*xReverse;
                            goalGroup.position.y += offsetFromLastFrame[1]*scale;

                            // stage.position.x += deltaX*scale*xReverse;
                            // stage.position.y += deltaY*scale;
                            // stage.rotation += deltaYaw;

                            currentFrame ++;
                          }
                          else{
                            currentFrame = 0;
                            isPlaying = false;
                          }
                        }
                        // if (frameCount > 50){
                        //   two.pause();
                        // }
                      }

                      

                      function addZUI() {
                        var domElement = two.renderer.domElement;
                        var zui = new Two.ZUI(stage);
                        var mouse = new Two.Vector();
                        var touches = {};
                        var distance = 0;
                        var dragging = false;

                        zui.zoomBy(0.7, 0, 0);
                        zui.addLimits(0.06, 8);

                        domElement.addEventListener('mousedown', mousedown, false);
                        domElement.addEventListener('mousewheel', mousewheel, false);
                        domElement.addEventListener('wheel', mousewheel, false);

                        domElement.addEventListener('touchstart', touchstart, false);
                        domElement.addEventListener('touchmove', touchmove, false);
                        domElement.addEventListener('touchend', touchend, false);
                        domElement.addEventListener('touchcancel', touchend, false);

                        function mousedown(e) {
                          mouse.x = e.clientX;
                          mouse.y = e.clientY;

                          // process btn actions
                          two.width/2 + 50, two.height-140
                          if (mouse.x < (two.width/2 + 50 - btnOffset / 2 * 0.2) && mouse.x > (two.width/2 + 50 - btnOffset / 2 * 1.2) 
                          && mouse.y > (two.height - 140 - 30) && mouse.y < (two.height - 140 + 30)){
                            isPlaying = !isPlaying;
                          }
                          else{
                            var rect = shape.getBoundingClientRect();
                            dragging = mouse.x > rect.left && mouse.x < rect.right
                              && mouse.y > rect.top && mouse.y < rect.bottom;
                            window.addEventListener('mousemove', mousemove, false);
                            window.addEventListener('mouseup', mouseup, false);
                          }
                        }

                        function mousemove(e) {
                          var dx = e.clientX - mouse.x;
                          var dy = e.clientY - mouse.y;
                          if (dragging) {
                            shape.position.x += dx / zui.scale;
                            shape.position.y += dy / zui.scale;
                          } else {
                            zui.translateSurface(dx, dy);
                          }
                          mouse.set(e.clientX, e.clientY);
                        }

                        function mouseup(e) {
                          window.removeEventListener('mousemove', mousemove, false);
                          window.removeEventListener('mouseup', mouseup, false);
                        }

                        function mousewheel(e) {
                          var dy = (e.wheelDeltaY || - e.deltaY) / 1000;
                          zui.zoomBy(dy, e.clientX, e.clientY);
                        }

                        function touchstart(e) {
                          switch (e.touches.length) {
                            case 2:
                              pinchstart(e);
                              break;
                            case 1:
                              panstart(e)
                              break;
                          }
                        }

                        function touchmove(e) {
                          switch (e.touches.length) {
                            case 2:
                              pinchmove(e);
                              break;
                            case 1:
                              panmove(e)
                              break;
                          }
                        }

                        function touchend(e) {
                          touches = {};
                          var touch = e.touches[ 0 ];
                          if (touch) {  // Pass through for panning after pinching
                            mouse.x = touch.clientX;
                            mouse.y = touch.clientY;
                          }
                        }

                        function panstart(e) {
                          var touch = e.touches[ 0 ];
                          mouse.x = touch.clientX;
                          mouse.y = touch.clientY;
                        }

                        function panmove(e) {
                          var touch = e.touches[ 0 ];
                          var dx = touch.clientX - mouse.x;
                          var dy = touch.clientY - mouse.y;
                          zui.translateSurface(dx, dy);
                          mouse.set(touch.clientX, touch.clientY);
                        }

                        function pinchstart(e) {
                          for (var i = 0; i < e.touches.length; i++) {
                            var touch = e.touches[ i ];
                            touches[ touch.identifier ] = touch;
                          }
                          var a = touches[ 0 ];
                          var b = touches[ 1 ];
                          var dx = b.clientX - a.clientX;
                          var dy = b.clientY - a.clientY;
                          distance = Math.sqrt(dx * dx + dy * dy);
                          mouse.x = dx / 2 + a.clientX;
                          mouse.y = dy / 2 + a.clientY;
                        }

                        function pinchmove(e) {
                          for (var i = 0; i < e.touches.length; i++) {
                            var touch = e.touches[ i ];
                            touches[ touch.identifier ] = touch;
                          }
                          var a = touches[ 0 ];
                          var b = touches[ 1 ];
                          var dx = b.clientX - a.clientX;
                          var dy = b.clientY - a.clientY;
                          var d = Math.sqrt(dx * dx + dy * dy);
                          var delta = d - distance;
                          zui.zoomBy(delta / 250, mouse.x, mouse.y);
                          distance = d;
                        }
                      }


                      // var circle = two.makeCircle(-70, 0, 50);
                      // var rect = two.makeRectangle(70, 0, 100, 100);
                      // circle.fill = '#FF8000';
                      // rect.fill = 'rgba(0, 200, 255, 0.75)';

                      // var cx = two.width * 0.5;
                      // var cy = two.height * 0.5;
                      // var group = two.makeGroup(circle, rect);
                      // group.position.set(cx, cy);
                      // group.scale = 0;
                      // group.noStroke();

                      // Bind a function to scale and rotate the group to the animation loop.
                      // two.bind('update', update);
                      // Finally, start the animation loop
                      // two.play();

                      // function update(frameCount) {
                      // // This code is called every time two.update() is called.
                      // // if (group.scale > 0.9999) {
                      // //   group.scale = group.rotation = 0;
                      // // }
                      // // var t = (1 - group.scale) * 0.125;
                      // // group.scale += t;
                      // // group.rotation += t * 4 * Math.PI;
                      // }

                      
                    </script>


  </body>
</html>
