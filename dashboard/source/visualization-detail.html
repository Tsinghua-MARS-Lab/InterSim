<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>InterSim - The Best Behaviour Simulator for Safe L4+ Autonomous Driving</title>

  <!-- GOOGLE FONTS -->
  <link href="https://fonts.googleapis.com/css?family=Karla:400,700|Roboto" rel="stylesheet">
  <link href="plugins/material/css/materialdesignicons.min.css" rel="stylesheet" />
  <link href="plugins/simplebar/simplebar.css" rel="stylesheet" />

  <!-- PLUGINS CSS STYLE -->
  <link href="plugins/nprogress/nprogress.css" rel="stylesheet" />
  <link href="plugins/DataTables/DataTables-1.10.18/css/jquery.dataTables.min.css" rel="stylesheet" />
  <link href="plugins/jvectormap/jquery-jvectormap-2.0.3.css" rel="stylesheet" />
  <link href="plugins/daterangepicker/daterangepicker.css" rel="stylesheet" />
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  <link href="plugins/toaster/toastr.min.css" rel="stylesheet" />
  <!-- MONO CSS -->
  <link id="main-css-href" rel="stylesheet" href="css/style.css" />
  <!-- FAVICON -->
  <link href="images/favicon.png" rel="shortcut icon" />

  <!--
    HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries
  -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="plugins/nprogress/nprogress.js"></script>
</head>


  <body class="navbar-fixed sidebar-fixed" id="body">
    <script>
      NProgress.configure({ showSpinner: false });
      NProgress.start();
    </script>

    <!-- ====================================
    ——— WRAPPER
    ===================================== -->
    <div class="wrapper">
        <!-- ====================================
          ——— LEFT SIDEBAR WITH OUT FOOTER
        ===================================== -->
        <aside class="left-sidebar sidebar-dark" id="left-sidebar">
          <div id="sidebar" class="sidebar">
            <!-- Aplication Brand -->
            <div class="app-brand">
              <a href="/index.html">
                <img class="mr-2" src="images/logo.png" alt="InterSim">
                <span class="brand-name"> <img src="images/logo_text.png" alt="InterSim"> </span>
                <!-- <span class="brand-name">InterSim</span> -->
              </a>
            </div>
            <!-- begin sidebar scrollbar -->
            <div class="sidebar-left" data-simplebar style="height: 100%;">
              <!-- sidebar menu -->
              <ul class="nav sidebar-inner" id="sidebar-menu">
                  <li>
                    <a class="sidenav-item-link" href="index.html">
                      <i class="mdi mdi-home-variant-outline"></i>
                      <span class="nav-text">Simulations</span>
                    </a>
                  </li>

                  <!-- <li>
                    <a class="sidenav-item-link" href="analytics.html">
                      <i class="mdi mdi-console"></i>
                      <span class="nav-text">Console & Notebook</span>
                    </a>
                  </li> -->
                
                  <li>
                    <a class="sidenav-item-link" href="list.html">
                      <i class="mdi mdi-chart-line"></i>
                      <span class="nav-text">Results & Summary</span>
                    </a>
                  </li>

                  <li class="active">
                    <a class="sidenav-item-link" href="visualization-detail.html">
                      <i class="mdi mdi-map"></i>
                      <span class="nav-text">Visualizations</span>
                    </a>
                  </li>

                  <!-- <li>
                    <a class="sidenav-item-link" href="visualization-online.html">
                      <i class="mdi mdi-hand"></i>
                      <span class="nav-text">Online Simulation</span>
                    </a>
                  </li>
                
                  <li>
                    <a class="sidenav-item-link" href="user-profile.html">
                      <i class="mdi mdi-account"></i>
                      <span class="nav-text">User Profile</span>
                    </a>
                  </li>                 -->
              </ul>
            </div>
          </div>
        </aside>

      

      <!-- ====================================
      ——— PAGE WRAPPER
      ===================================== -->
      <div class="page-wrapper">
        
          <!-- Header -->
          <header class="main-header" id="header">
            <nav class="navbar navbar-expand-lg navbar-light" id="navbar">
              <!-- Sidebar toggle button -->
              <button id="sidebar-toggler" class="sidebar-toggle">
                <span class="sr-only">Toggle navigation</span>
              </button>

              <span class="page-title">Visualizations</span>

              <div class="navbar-right ">

                <a class="dropdown-link-item mr-5" href="https://www.linkedin.com/in/qiao-sun/" target="_blank">
                  <span class="nav-text">Qiao Sun &#64 Shanghai QiZhi</span>
                </a>

                <!-- <span herf="#www.bing.com" class="d-none d-lg-inline-block mr-5">Qiao Sun &#64 Shanghai QiZhi</span> -->
              </div>
            </nav>

            <nav aria-label="breadcrumb">
              <ol class="breadcrumb breadcrumb-light" id="breadcrumb">
                <li class="breadcrumb-item">  <a href="index.html">All Simulations  </a>  </li>
                <li class="breadcrumb-item">  <a href="list.html" id="breadcrumb_task">This Simulation Task  </a>  </li>
                <li class="breadcrumb-item">  <a href="list.html" id="breadcrumb_experiment">This Experiment Name  </a>  </li>
                <li class="breadcrumb-item active"  aria-current="page" id="breadcrumb_scene">  This Scenario Id </li>
              </ol>
            </nav>

          </header>

        <!-- ====================================
        ——— CONTENT WRAPPER
        ===================================== -->
        <div class="content-wrapper">
          <div class="content">     

            <!-- <nav aria-label="breadcrumb">
              <ol class="breadcrumb">
                <li class="breadcrumb-item">  <a href="#">All Simulations  </a>  </li>
                <li class="breadcrumb-item">  <a href="#">This Simulation Task  </a>  </li>
                <li class="breadcrumb-item">  <a href="#">This Experiment Name  </a>  </li>
                <li class="breadcrumb-item active"  aria-current="page">  This Scenario Id </li>
              </ol>
            </nav> -->

            <div class="row">
              <div class="col-12">       
                <div class="card card-default">
                  <div class="card-header">
                    <h2>Visulization & Perturbation</h2>
                    <a href="#" class="text-uppercase">Usage Guild Doc</a>
                  </div>
                  <div class="card-body" id="twoCanvas">
                    <a></a>
                    <!-- <div class="border p-6">
                      ?
                    </div> -->
                  </div>
                </div>
              </div>
            </div>
        </div>
          
        </div>
        
          <!-- Footer -->
          <footer class="footer mt-auto">
            <div class="copyright bg-white">
              <p>
                &copy; <span id="copy-year"></span> Copyright InterSim by <a class="text-primary" href="mailto: alan.qiao.sunATgmail.com" target="_blank" >Qiao Sun</a>.
              </p>
            </div>
            <script>
                var d = new Date();
                var year = d.getFullYear();
                document.getElementById("copy-year").innerHTML = year;
            </script>
          </footer>

      </div>
    </div>
    
                    <script src="plugins/jquery/jquery.min.js"></script>
                    <script src="plugins/bootstrap/js/bootstrap.bundle.min.js"></script>
                    <script src="plugins/simplebar/simplebar.min.js"></script>
                    <script src="https://unpkg.com/hotkeys-js/dist/hotkeys.min.js"></script>
                    <script src="plugins/apexcharts/apexcharts.js"></script>
                    <script src="plugins/DataTables/DataTables-1.10.18/js/jquery.dataTables.min.js"></script>
                    <script src="plugins/jvectormap/jquery-jvectormap-2.0.3.min.js"></script>
                    <script src="plugins/jvectormap/jquery-jvectormap-world-mill.js"></script>
                    <script src="plugins/jvectormap/jquery-jvectormap-us-aea.js"></script>
                    <script src="plugins/daterangepicker/moment.min.js"></script>
                    <script src="plugins/daterangepicker/daterangepicker.js"></script>
                    <script>
                      jQuery(document).ready(function() {
                        jQuery('input[name="dateRange"]').daterangepicker({
                        autoUpdateInput: false,
                        singleDatePicker: true,
                        locale: {
                          cancelLabel: 'Clear'
                        }
                      });
                        jQuery('input[name="dateRange"]').on('apply.daterangepicker', function (ev, picker) {
                          jQuery(this).val(picker.startDate.format('MM/DD/YYYY'));
                        });
                        jQuery('input[name="dateRange"]').on('cancel.daterangepicker', function (ev, picker) {
                          jQuery(this).val('');
                        });
                      });
                    </script>
                    
                    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

                    <script src="plugins/toaster/toastr.min.js"></script>

                    
                    
                    <script src="js/mono.js"></script>
                    <script src="js/chart.js"></script>
                    <script src="js/map.js"></script>
                    <script src="js/custom.js"></script>

                    <!-- <script type="module" src="js/draw.js"></script> -->
                    <script src="js/two.js"></script>
                    <script src="js/zui.js"></script>

                    <!--  -->

                    <script>
                      // var agentData = require('data/agent_instances.json');
                      // console.log(agentData);
                      
                      
                      function GetURLParameter(sParam)
                      {
                          var sPageURL = window.location.search.substring(1);
                          var sURLVariables = sPageURL.split('&');
                          for (var i = 0; i < sURLVariables.length; i++)
                          {
                              var sParameterName = sURLVariables[i].split('=');
                              if (sParameterName[0] == sParam)
                              {
                                  return sParameterName[1];
                              }
                          }
                      }
                      
                      var params = {
                      fullscreen: true,
                      autostart: true
                      };
                      
                      // var elem = document.getElementById('twoCanvas');
                      var elem = document.body;
                      // elem.style.height = (document.documentElement.clientHeight - 370).toString() + 'px';
                      // var elem = document.body;
                      var two = new Two(params).appendTo(elem);
                      // two.renderer.domElement.style.background = 'rgb(0, 191, 168)';
                      two.renderer.domElement.style.background = 'rgb(0, 128, 150)';
                      // two.renderer.domElement.style.background = 'black';
                      // two.width = elem.clientWidth - 70;
                      // two.height = elem.clientHeight - 70;

                      var stage = new Two.Group();
                      var shape = new Two.Rectangle(0, 0, 1, 1);
                      var offsets = undefined;

                      // LANE = 0
                      // INTERSECTION = 1
                      // STOP_LINE = 2
                      // TURN_STOP = 3
                      // CROSSWALK = 4
                      // DRIVABLE_AREA = 5
                      // YIELD = 6
                      // TRAFFIC_LIGHT = 7
                      // STOP_SIGN = 8
                      // EXTENDED_PUDO = 9
                      // SPEED_BUMP = 10
                      // LANE_CONNECTOR = 11
                      // BASELINE_PATHS = 12
                      // WALKWAYS = 13
                      // CARPARK_AREA = 14
                      // PUDO = 15
                      // ROADBLOCK = 16
                      // ROADBLOCK_CONNECTOR = 17

                      const polyTypes = [16, 1];
                      var lineTypes = [0];
                      const rectTypes = [99];
                      const scale = 5;
                      const lineWidth = 1;
                      const xReverse = -1;
                      var agentPoly = {};
                      const btnOffset = 70;
                      var isPlaying = false;
                      var currentFrame = 0;
                      var totalFrame = undefined;
                      var loadedData = undefined;
                      var playBtn = two.load('./images/icons/play.svg');
                      var pauseBtn = two.load('./images/icons/pause.svg');
                      var agentGroup = new Two.Group();
                      var mapGroup = new Two.Group();
                      var goalGroup = new Two.Group();
                      var percCirclesGroup = new Two.Group();
                      var offsetFromLastFrame = [0, 0, 0];
                      var maxFrames = 80;
                      var lanes_to_mark = undefined;
                      var goal_pts = undefined;      
                      var currentScene = 0;    
                      var egoId = 'ego';          

                      const queryString = window.location.search;
                      const urlParams = new URLSearchParams(queryString);
                      const taskName = urlParams.get('task');
                      const simName = urlParams.get('sim');
                      const sceneId = urlParams.get('sceneid');
                      const fileId = urlParams.get('fileid');
                      const datasetNameWithMap = simName.split("_")[1];
                      const datasetName = datasetNameWithMap.split("-")[0];
                      var loadDemo = false;
                      
                      if (taskName !== null){
                        document.getElementById('breadcrumb_task').href = "list.html?task=" + taskName;
                        document.getElementById('breadcrumb_task').innerHTML = taskName;
                      }
                      else{
                        loadDemo = true;
                      }
                      if (simName !== null && datasetNameWithMap !== null){
                        document.getElementById('breadcrumb_experiment').href = "list.html?task=" + taskName + "&dataset=" + datasetNameWithMap + "&sim=" + simName;
                        document.getElementById('breadcrumb_experiment').innerHTML = simName;
                      }
                      else{
                        loadDemo = true;
                      }
                      if (sceneId !== null){
                        document.getElementById('breadcrumb_scene').innerHTML = sceneId;
                      }
                      else{
                        loadDemo = true;
                      }
                      

                      function drawPoly(dic, selected){
                        const roadType = dic['type'];
                        if (selected.includes(roadType)){
                          var pointsArray = new Array();
                          const points = dic['xyz'];
                          for (let xyzArray of points){
                            if (offsets === undefined){
                              offsets = [-xyzArray[0], -xyzArray[1]];
                            }
                            pointsArray.push(new Two.Anchor((xyzArray[0]+offsets[0])*scale*xReverse, (xyzArray[1]+offsets[1])*scale));
                          }
                          var poly = two.makePath(pointsArray);
                          // draw polygons
                          // var poly = new two.makePath);
                          poly.linewidth = lineWidth / 2;
                          poly.opacity = 0.5;
                          if (polyTypes.includes(roadType)){
                            poly.fill = 'gray';
                            poly.opacity = 1;
                          }
                          else if (roadType == 4){
                            poly.fill = 'white';
                          }
                          else if (roadType == 2){
                            poly.fill = 'red';
                          }
                          else if (roadType == 13){
                            poly.fill = 'brown';
                          }
                          else if (roadType == 14){
                            poly.fill = 'blue';
                          }
                          else{
                            poly.fill = 'black';
                          }
                          mapGroup.add(poly);
                        }
                      }
                      
                      function drawALine(points, arrow, color, dash, continuous = false){
                        var ptCounter = 0;
                        var prev_x = undefined;
                        var prev_y = undefined;
                        var interval = 0;
                        if (dash){
                          interval = 10;
                        }
                        for (let xyzArray of points){
                          if (ptCounter == interval){
                            ptCounter = 0;
                          }
                          else{
                            ptCounter ++;
                            continue;
                          }
                          if (prev_x === undefined){
                            prev_x = (xyzArray[0] + offsets[0]) * scale * xReverse;
                            prev_y = (xyzArray[1] + offsets[1]) * scale;
                          }
                          else{
                            x = (xyzArray[0] + offsets[0]) * scale * xReverse;
                            y = (xyzArray[1] + offsets[1]) * scale;
                            if (arrow){
                              var line = two.makeArrow(prev_x, prev_y, x, y);
                              line.linewidth = lineWidth*3;
                            }
                            else{
                              var line = two.makeLine(prev_x, prev_y, x, y);
                              // line.stroke = 'white';
                              line.linewidth = lineWidth;
                            }
                            prev_x = x;
                            prev_y = y;
                            line.stroke = color;
                            mapGroup.add(line);
                            if (!continuous){
                              prev_x = undefined;
                              prev_y = undefined;
                            }
                          }
                        }
                      }
                      function drawLanes(roads){
                        if (datasetName === 'Waymo'){
                          for (var key in roads){
                            const dic = roads[key];
                            var roadType = dic['type'];
                            if (Array.isArray(roadType)){
                              roadType = roadType[0];
                            }
                            const pointsToGo = dic['xyz'];
                            if (roadType == 1){
                              drawALine(pointsToGo, false, 'brown', false);
                            }
                            if (roadType == 2){
                              drawALine(pointsToGo, false, 'rgba(80,0,94,1)', false);
                            }
                            if (roadType == 3){
                              drawALine(pointsToGo, false, 'blue', false);
                            }
                            if (roadType == 6){
                              drawALine(pointsToGo, false, 'white', true);
                            }
                            if (roadType == 8){
                              drawALine(pointsToGo, false, 'white', false, true);
                            }
                            if (roadType == 9){
                              drawALine(pointsToGo, false, 'yellow', false, true);
                            }
                            if (roadType == 10){
                              drawALine(pointsToGo, false, 'rgba(235, 207, 111, 1)', true);
                            }
                            if (roadType == 11){
                              drawALine(pointsToGo, false, 'yellow', false, true);
                            }
                            if (roadType == 12){
                              drawALine(pointsToGo, false, 'yellow', false, true);
                            }
                            if (roadType == 13){
                              drawALine(pointsToGo, false, 'rgba(235, 207, 111, 1)', false, true);
                            }
                            if (roadType == 15){
                              drawALine(pointsToGo, false, 'green', false, true);
                            }
                            if (roadType == 16){
                              drawALine(pointsToGo, false, 'rgba(0, 235, 132, 1)', false, true);
                            }
                            if (roadType == 18){
                              drawALine(pointsToGo, false, 'purple', false, true);
                            }
                            if (roadType == 19){
                              drawALine(pointsToGo, false, 'red', false, true);
                            }
                          }
                        }
                        if (datasetName === 'NuPlan'){
                          for (var key in roads) {
                            const dic = roads[key];
                            var roadType = dic['type'];
                            if (Array.isArray(roadType)){
                              roadType = roadType[0];
                            }
                            const pointsToGo = dic['xyz'];
                            if (lineTypes.includes(roadType)){
                              var to_mark = false;
                              var colorToGo = 'white'
                              var dashToGO = true;
                              if (lanes_to_mark !== undefined && lanes_to_mark.includes(key)){
                                to_mark = true;
                                colorToGo = 'black'
                                dashToGO = true;
                              }
                              drawALine(pointsToGo, to_mark, colorToGo, dashToGO);

                              // var ptCounter = 0;
                              // prev_x = undefined;
                              // prev_y = undefined;
                              // const points = dic['xyz'];

                              // if (offsets === undefined){
                              //     offsets = [-points[0][0], -points[0][1]];
                              //   }
                              // x0 = (points[0][0] + offsets[0]) * scale * xReverse;
                              // y0 = (points[0][1] + offsets[1]) * scale;
                              // if (true){  // (Math.abs(x0) < 3000 && Math.abs(y0) < 3000){
                              //   for (let xyzArray of points){
                              //     if (ptCounter == 10){
                              //       ptCounter = 0;
                              //     }
                              //     else{
                              //       ptCounter ++;
                              //       continue;
                              //     }
                              //     if (prev_x === undefined){
                              //       prev_x = (xyzArray[0] + offsets[0]) * scale * xReverse;
                              //       prev_y = (xyzArray[1] + offsets[1]) * scale;
                              //     }
                              //     else{
                              //       x = (xyzArray[0] + offsets[0]) * scale * xReverse;
                              //       y = (xyzArray[1] + offsets[1]) * scale;
                              //       if (lanes_to_mark !== undefined && lanes_to_mark.includes(key)){
                              //         var line = two.makeArrow(prev_x, prev_y, x, y);
                              //         prev_x = x;
                              //         prev_y = y;
                              //         line.stroke = 'black';
                              //         line.linewidth = lineWidth*3;
                              //       }
                              //       else{
                              //         var line = two.makeLine(prev_x, prev_y, x, y);
                              //         prev_x = x;
                              //         prev_y = y;
                              //         line.stroke = 'white';
                              //         line.linewidth = lineWidth;
                              //     }
                              //       mapGroup.add(line);
                              //       prev_x = undefined;
                              //       prev_y = undefined;
                              //     }
                              //   }
                              // }
                            }
                          }
                        }
                      }
                      function drawMap(roads){
                        for (var key in roads) {
                          drawPoly(roads[key], polyTypes);  // 17=1
                        }
                        // draw lanes
                        drawLanes(roads);
                        // draw others
                        for (var key in roads) {
                          drawPoly(roads[key], [2, 4, 13, 14, 7, 8]);  // no 3, 5, 6
                        }
                        // draw parking lots
                        for (var key in roads) {  
                          const dic = roads[key];
                          const roadType = dic['type'];
                          if (rectTypes.includes(roadType)){
                            const points = dic['xyz'];
                            rectShape = dic['shape'];
                            x = (points[0] + offsets[0]) * scale * xReverse;
                            y = (points[1] + offsets[1]) * scale;
                            var rect = two.makeRectangle(x, y, rectShape[0]*scale, rectShape[1]*scale);
                            rect.rotation = Math.PI/2 - dic['dir'];
                            rect.fill = 'white';
                            rect.opacity = 0.3;
                            mapGroup.add(rect);
                          }                          
                        }

                        // draw circle
                        circle = two.makeCircle(two.width / 4, two.height / 4, 300*scale);
                        // circle.fill = 'gray';
                        circle.opacity = 0.2;
                        circle.stroke = 'red';
                        percCirclesGroup.add(circle);
                        circle = two.makeCircle(two.width / 4, two.height / 4, 150*scale);
                        // circle.fill = 'gray';
                        circle.stroke = 'green';
                        circle.opacity = 0.2;
                        percCirclesGroup.add(circle);
                        stage.add(percCirclesGroup);

                        stage.add(mapGroup);

                        // for (var i = 0; i < 1; i++) {
                        //   var x = 10000; //Math.random() * two.width * 2 - two.width;
                        //   var y = 10000; //Math.random() * two.height * 2 - two.height;
                        //   var size = 10;
                        //   shape = new Two.Rectangle(x, y, size, size);
                        //   shape.rotation = Math.random() * Math.PI * 2;
                        //   shape.noStroke().fill = '#ccc';
                        //   // shape.opacity = 0.2;
                        //   stage.add(shape);
                        // }

                        // shape.fill = 'red';
                        // shape.position.set(two.width / 4, two.height / 4);
                        two.add(stage);
                      }

                      function drawScenario(dataDic, scenarioId){
                        var agents = dataDic[scenarioId]['agent'];
                        for (var key in agents){
                          [x, y, z, yaw] = agents[key]['pose'][0];
                          if (totalFrame === undefined){
                            totalFrame = agents[key]['pose'].length;
                          }
                          else{
                            totalFrame = Math.min(totalFrame, agents[key]['pose'].length);
                          }
                          // yaw = 0;
                          if (x == -1){
                            continue;
                          }
                          [w, h] = agents[key]['shape'][0];

                          var pointsArray = new Array();
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse-w*scale/2, (y+offsets[1])*scale-h*scale/2));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale-h*scale/2*1.3));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse+w*scale/2, (y+offsets[1])*scale-h*scale/2));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse+w*scale/2, (y+offsets[1])*scale+h*scale/2));
                          pointsArray.push(new Two.Anchor((x+offsets[0])*scale*xReverse-w*scale/2, (y+offsets[1])*scale+h*scale/2));
                          var poly = two.makePath(pointsArray);

                          // poly = new Two.Rectangle((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale, w*scale, h*scale);
                          if (key == egoId){
                            poly.fill = 'white';
                          }
                          else{
                            poly.fill = 'green';
                            if ('predicting' in dataDic[scenarioId] && 'relevant_agents' in dataDic[scenarioId]['predicting']){
                              if (typeof(dataDic[scenarioId]['predicting']['relevant_agents'][0]) == typeof(key)){
                                if (dataDic[scenarioId]['predicting']['relevant_agents'].includes(key)){
                                  poly.fill = 'yellow';
                                }
                              }
                              else{
                                if (dataDic[scenarioId]['predicting']['relevant_agents'].includes(parseInt(key))){
                                  poly.fill = 'yellow';
                                }
                              }
                            }
                          }
                          // poly.rotation = -Math.PI/2+yaw;
                          // Math.PI/2 - dic['dir'];
                          // poly.rotation = yaw;
                          poly.rotation = -yaw - Math.PI/2;
                          agentPoly[key] = poly;
                          agentGroup.add(poly);
                        }
                        stage.add(agentGroup);
                      }

                      function drawGoals(dataDic, scenarioId){
                        // var goals = dataDic[scenarioId]['ltp_goals'];
                        // if (goals !== undefined){
                        //   goalGroup = new Two.Group();
                        //   for (var goal of goals){
                        //     const pt = goal[0];
                        //     [x, y] = pt;
                        //     // poly = two.makeArrow((x+offsets[0])*scale*xReverse, (y-5+offsets[1])*scale, 
                        //     // (x+offsets[0])*scale*xReverse, (y+offsets[1])*scale, 30);
                        //     // poly.center();
                        //     // poly.position.x = (x+offsets[0])*scale*xReverse;
                        //     // poly.position.y = (y+offsets[1])*scale;
                        //     // poly.stroke = 'red';
                        //     var line = two.makeLine((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale,
                        //     (x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale);
                        //     line.stroke = 'black';
                        //     goalGroup.add(line);
                        //     var circle = two.makeCircle((x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale, 2*scale);
                        //     circle.fill = 'red';
                        //     goalGroup.add(circle);
                        //   }
                        // }
                        // stage.add(goalGroup);
                        if (goal_pts !== undefined){
                          goalGroup = new Two.Group();
                          [x, y] = goal_pts;
                          var line = two.makeLine((x+offsets[0])*scale*xReverse, (y+offsets[1])*scale, (x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale);
                          line.stroke = 'black';
                          goalGroup.add(line);
                          var circle = two.makeCircle((x+offsets[0])*scale*xReverse, (y-6+offsets[1])*scale, 2*scale);
                          circle.fill = 'red';
                          goalGroup.add(circle);                          
                          stage.add(goalGroup);
                        }
                      }

                      function setOffset(){
                        if (loadedData !== undefined && currentFrame !== undefined){
                          if (datasetName == 'Waymo'){
                            egoId = loadedData['predicting']['ego_id'][1];
                            var ego = loadedData['agent'][egoId];
                          }
                          if (datasetName == 'NuPlan'){
                            egoId = 'ego';
                            var ego = loadedData['agent'][egoId];
                          }
                          [x, y, z, yaw] = ego['pose'][currentFrame];
                          if (offsets !== undefined){
                            var dx = -x - two.width / 4 / scale - offsets[0];
                            var dy = -y + two.height / 4 / scale - offsets[1];
                            // var dyaw = -yaw - offsets[2];
                            // offsetFromLastFrame = [dx, dy, dyaw];
                            offsetFromLastFrame = [dx, dy, 0];
                          }
                          // offsets = [-x - two.width / 4 / scale, -y + two.height / 4 / scale, -yaw];
                          // offsets = [-x - two.width / 4 / scale, -y + two.height / 4 / scale, yaw*xReverse];
                          offsets = [-x - two.width / 4 / scale, -y + two.height / 4 / scale, 0];
                        }
                        if (lanes_to_mark === undefined){
                          lanes_to_mark = [];
                          if (ego['current_route'] !== undefined){
                            for (const each_route of ego['current_route']){
                            for (const lane_id of each_route){
                              if (!lanes_to_mark.includes(lane_id)){
                                lanes_to_mark.push(lane_id);
                              } 
                            }
                            console.log(each_route);
                            console.log(lanes_to_mark);
                            }
                          }
                          if (loadedData['predicting']['route'][egoId] !== undefined){
                            for (const each_lane_id of loadedData['predicting']['route'][egoId]){
                              if (!lanes_to_mark.includes(each_lane_id)){
                                lanes_to_mark.push(each_lane_id);
                              }
                            }
                          }
                        }

                        if (goal_pts === undefined){
                          if (loadedData['goals'] !== undefined){
                            goal_pts = loadedData['goals'][egoId][0][0];
                          }
                          if (loadedData['predicting']['goal_pts'][egoId] !== undefined){
                            goal_pts = loadedData['predicting']['goal_pts'][egoId][0];
                          }
                          
                        }
                      }

                      function addBtn(){
                          
                          var btnGroup = new Two.Group();

                          var panel = two.makeRoundedRectangle(two.width/2 + 65, two.height - 123, 390, 70, 35);
                          panel.fill = 'white';
                          btnGroup.add(panel);

                          playBtn.position.set(two.width/2 + 50, two.height-140);
                          playBtn.scale = 0.07;
                          // playBtn.opacity = 1;
                          btnGroup.add(playBtn);

                          pauseBtn.position.set(two.width/2 + 50, two.height-140);
                          pauseBtn.scale = 0.75;
                          pauseBtn.opacity = 0;
                          btnGroup.add(pauseBtn);

                          var nextFrameBtn = two.load('./images/icons/next-frame.svg');
                          nextFrameBtn.position.set(two.width/2 + 50 + btnOffset, two.height-140);
                          nextFrameBtn.scale = 0.12;
                          btnGroup.add(nextFrameBtn);

                          var nextScenarioBtn = two.load('./images/icons/next-scenario.svg');
                          nextScenarioBtn.position.set(two.width/2 + 50 + btnOffset * 2, two.height-140);
                          nextScenarioBtn.scale = 0.07;
                          btnGroup.add(nextScenarioBtn);

                          var previousFrameBtn = two.load('./images/icons/previous-frame.svg');
                          previousFrameBtn.position.set(two.width/2 + 50 - btnOffset, two.height-140);
                          previousFrameBtn.scale = 0.07;
                          btnGroup.add(previousFrameBtn);

                          var previousScenarioBtn = two.load('./images/icons/previous-scenario.svg');
                          previousScenarioBtn.position.set(two.width/2 + 50 - btnOffset * 2, two.height-140);
                          previousScenarioBtn.scale = 0.07;
                          btnGroup.add(previousScenarioBtn);

                          var previousScenarioBtn = two.load('./images/icons/previous-scenario.svg');
                          previousScenarioBtn.position.set(two.width/2 + 50 - btnOffset * 2, two.height-140);
                          previousScenarioBtn.scale = 0.07;
                          btnGroup.add(previousScenarioBtn);

                          two.add(btnGroup);
                        }
                      
                      var getScenario = function (index, callback){
                        // Creating a XHR object
                        let xhr = new XMLHttpRequest();
                        let url = "http://127.0.0.1:5000/vis?sim=" + String(simName) + "&sceneid=" + String(sceneId) + "&fileid=" + String(fileId);
                        // open a connection
                        xhr.open("GET", url, true);
                        // Set the request header i.e. which type of content you are sending
                        // xhr.setRequestHeader("Content-Type", "application/json");
                        xhr.responseType = 'json';
                        xhr.onload = function() {
                          var status = xhr.status;
                          if (status === 200) {
                            callback(null, xhr.response);
                          } else {
                            callback(status, xhr.response);
                          }
                        };
                        xhr.send();
                      }

                      if (loadDemo){
                        console.log('No Valid Parameters to Load!');
                        // const roads = Object.keys(data['map']['road']);
                        //   localStorage['road'] = JSON.stringify(roads);
                        //   console.log(JSON.parse(localStorage['road']));
                          
                        //   fetch("./scenarios/demo/demo.json")
                        //   fetch("./scenarios/demo/2021.08.18.18.32.06_veh-28_00049_00111.json")
                        //   .then(response => response.json())
                        //   .then(data => {
                        //   })
                      }
                      else {
                        if (datasetName == 'NuPlan'){
                          // loading (cannot save to local, because over the quota of local storage) 
                          fetch("./scenarios/demo/boston_map.json")
                          .then(response => response.json())
                          .then(data => {
                            const roads = data['map']['road'];
                            getScenario(0,  function(err, data) {
                              if (err != null) {
                                  console.error('Something went wrong: ' + err);
                              } else {
                                const sceneIndex = data['selected_scene_index'];
                                const key = Object.keys(data)[sceneIndex];
                                loadedData = data[key];
                                if (loadedData['info'] !== undefined){
                                  maxFrames = loadedData['info']['max_frames'];
                                }
                                setOffset();
                                drawMap(roads);
                                drawScenario(data, key);
                                drawGoals(data, key);
                                addBtn();
                                // Bind a function to scale and rotate the group to the animation loop.
                                two.bind('update', update);
                                // Finally, start the animation loop
                                two.play();
                                addZUI();
                              }
                            });
                          })
                        }
                        if (datasetName == 'Waymo'){
                          console.log('waymo');
                          getScenario(0,  function(err, data) {
                              if (err != null) {
                                  console.error('Something went wrong: ' + err);
                              } else {
                                const sceneIndex = data['selected_scene_index'];
                                const key = Object.keys(data)[sceneIndex];
                                loadedData = data[key];
                                if (loadedData['info'] !== undefined){
                                  maxFrames = loadedData['info']['max_frames'];
                                }
                                const roads = loadedData['road'];
                                setOffset();
                                drawMap(roads);
                                drawScenario(data, key);
                                drawGoals(data, key);
                                addBtn();
                                // // Bind a function to scale and rotate the group to the animation loop.
                                two.bind('update', update);
                                // // Finally, start the animation loop
                                two.play();
                                addZUI();
                                console.log(totalFrame);
                              }
                            });
                        }
                        

                        
                          
                        


                        

                      }

                      // var info = {'file_names': ['1', '2', '3'], 'scenario_ids': [123, 234, 345]};
                      // localStorage['list'] = JSON.stringify(info);
                      // localStorage['list'] = [[0, 1], [2, 3], [4, 'sjdiofjs']];


                      var FRAMERATE = 6;  //10fps
                      
                      function update(frameCount){
                        
                        if (isPlaying){
                          playBtn.opacity = 0;
                          pauseBtn.opacity = 1;
                        }
                        else{
                          playBtn.opacity = 1;
                          pauseBtn.opacity = 0;
                        }
                        if (isPlaying && totalFrame !== undefined && loadedData !== undefined 
                        && frameCount % FRAMERATE == 0){
                          console.log(currentFrame);
                          if (currentFrame < totalFrame && currentFrame < maxFrames){
                            setOffset();
                            agents = loadedData['agent'];
                            for (var key in agentPoly){
                              poly = agentPoly[key];
                              [x, y, z, yaw] = agents[key]['pose'][currentFrame];
                              // [w, h] = agents[key]['shape'][currentFrame];
                              [w, h] = agents[key]['shape'][0];
                              poly.position.x = (x+offsets[0])*scale*xReverse;
                              poly.position.y = (y+offsets[1])*scale;
                              poly.rotation = - yaw - Math.PI/2;
                              // poly.rotation = yaw;
                              // poly.shape.width = w;
                              // poly.shape.height = h;
                            }
                            mapGroup.position.x += offsetFromLastFrame[0]*scale*xReverse;
                            mapGroup.position.y += offsetFromLastFrame[1]*scale;

                            goalGroup.position.x += offsetFromLastFrame[0]*scale*xReverse;
                            goalGroup.position.y += offsetFromLastFrame[1]*scale;

                            // stage.position.x += deltaX*scale*xReverse;
                            // stage.position.y += deltaY*scale;
                            // stage.rotation += deltaYaw;

                            currentFrame ++;
                          }
                          else{
                            currentFrame = 0;
                            isPlaying = false;
                          }
                        }
                        // console.log(frameCount);
                        // if (frameCount > 50){
                        //   two.pause();
                        // }
                      }

                      

                      function addZUI() {
                        var domElement = two.renderer.domElement;
                        var zui = new Two.ZUI(stage);
                        var mouse = new Two.Vector();
                        var touches = {};
                        var distance = 0;
                        var dragging = false;

                        zui.zoomBy(0.7, 0, 0);
                        zui.addLimits(0.06, 8);

                        domElement.addEventListener('mousedown', mousedown, false);
                        domElement.addEventListener('mousewheel', mousewheel, false);
                        domElement.addEventListener('wheel', mousewheel, false);

                        domElement.addEventListener('touchstart', touchstart, false);
                        domElement.addEventListener('touchmove', touchmove, false);
                        domElement.addEventListener('touchend', touchend, false);
                        domElement.addEventListener('touchcancel', touchend, false);

                        function mousedown(e) {
                          mouse.x = e.clientX;
                          mouse.y = e.clientY;

                          // process btn actions
                          two.width/2 + 50, two.height-140
                          if (mouse.x < (two.width/2 + 50 + btnOffset / 2 * 1.2) && mouse.x > (two.width/2 + 50 - btnOffset / 2 * 0.2) 
                          && mouse.y > (two.height - 140 - 30) && mouse.y < (two.height - 140 + 30)){
                            isPlaying = !isPlaying;
                          }
                          else{
                            var rect = shape.getBoundingClientRect();
                            dragging = mouse.x > rect.left && mouse.x < rect.right
                              && mouse.y > rect.top && mouse.y < rect.bottom;
                            window.addEventListener('mousemove', mousemove, false);
                            window.addEventListener('mouseup', mouseup, false);
                          }
                        }

                        function mousemove(e) {
                          var dx = e.clientX - mouse.x;
                          var dy = e.clientY - mouse.y;
                          if (dragging) {
                            shape.position.x += dx / zui.scale;
                            shape.position.y += dy / zui.scale;
                          } else {
                            zui.translateSurface(dx, dy);
                          }
                          mouse.set(e.clientX, e.clientY);
                        }

                        function mouseup(e) {
                          window.removeEventListener('mousemove', mousemove, false);
                          window.removeEventListener('mouseup', mouseup, false);
                        }

                        function mousewheel(e) {
                          var dy = (e.wheelDeltaY || - e.deltaY) / 1000;
                          zui.zoomBy(dy, e.clientX, e.clientY);
                        }

                        function touchstart(e) {
                          switch (e.touches.length) {
                            case 2:
                              pinchstart(e);
                              break;
                            case 1:
                              panstart(e)
                              break;
                          }
                        }

                        function touchmove(e) {
                          switch (e.touches.length) {
                            case 2:
                              pinchmove(e);
                              break;
                            case 1:
                              panmove(e)
                              break;
                          }
                        }

                        function touchend(e) {
                          touches = {};
                          var touch = e.touches[ 0 ];
                          if (touch) {  // Pass through for panning after pinching
                            mouse.x = touch.clientX;
                            mouse.y = touch.clientY;
                          }
                        }

                        function panstart(e) {
                          var touch = e.touches[ 0 ];
                          mouse.x = touch.clientX;
                          mouse.y = touch.clientY;
                        }

                        function panmove(e) {
                          var touch = e.touches[ 0 ];
                          var dx = touch.clientX - mouse.x;
                          var dy = touch.clientY - mouse.y;
                          zui.translateSurface(dx, dy);
                          mouse.set(touch.clientX, touch.clientY);
                        }

                        function pinchstart(e) {
                          for (var i = 0; i < e.touches.length; i++) {
                            var touch = e.touches[ i ];
                            touches[ touch.identifier ] = touch;
                          }
                          var a = touches[ 0 ];
                          var b = touches[ 1 ];
                          var dx = b.clientX - a.clientX;
                          var dy = b.clientY - a.clientY;
                          distance = Math.sqrt(dx * dx + dy * dy);
                          mouse.x = dx / 2 + a.clientX;
                          mouse.y = dy / 2 + a.clientY;
                        }

                        function pinchmove(e) {
                          for (var i = 0; i < e.touches.length; i++) {
                            var touch = e.touches[ i ];
                            touches[ touch.identifier ] = touch;
                          }
                          var a = touches[ 0 ];
                          var b = touches[ 1 ];
                          var dx = b.clientX - a.clientX;
                          var dy = b.clientY - a.clientY;
                          var d = Math.sqrt(dx * dx + dy * dy);
                          var delta = d - distance;
                          zui.zoomBy(delta / 250, mouse.x, mouse.y);
                          distance = d;
                        }
                      }


                      // var circle = two.makeCircle(-70, 0, 50);
                      // var rect = two.makeRectangle(70, 0, 100, 100);
                      // circle.fill = '#FF8000';
                      // rect.fill = 'rgba(0, 200, 255, 0.75)';

                      // var cx = two.width * 0.5;
                      // var cy = two.height * 0.5;
                      // var group = two.makeGroup(circle, rect);
                      // group.position.set(cx, cy);
                      // group.scale = 0;
                      // group.noStroke();

                      // Bind a function to scale and rotate the group to the animation loop.
                      // two.bind('update', update);
                      // Finally, start the animation loop
                      // two.play();

                      // function update(frameCount) {
                      // // This code is called every time two.update() is called.
                      // // if (group.scale > 0.9999) {
                      // //   group.scale = group.rotation = 0;
                      // // }
                      // // var t = (1 - group.scale) * 0.125;
                      // // group.scale += t;
                      // // group.rotation += t * 4 * Math.PI;
                      // }

                      
                    </script>


  </body>
</html>
